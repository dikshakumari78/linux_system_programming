#include <iostream>
#include <fcntl.h>
#include <unistd.h>
#include <cstring>
#include <cerrno>
#include <cstdlib>

void handleError(const char* msg) {
    std::cerr << msg << ": " << strerror(errno) << std::endl;
    exit(EXIT_FAILURE);
}

int main() {
    const char* filename = "example.txt";
    const char* content = "Hello, World!";
    char buffer[256];
    ssize_t bytesWritten, bytesRead;
    
    // Create a file with read and write permissions, truncate if it already exists
    int fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
    if (fd == -1) {
        handleError("Failed to open file");
    }

    // Write to the file
    bytesWritten = write(fd, content, strlen(content));
    if (bytesWritten == -1) {
        close(fd);
        handleError("Failed to write to file");
    }

    // Ensure all bytes are written
    if (bytesWritten != static_cast<ssize_t>(strlen(content))) {
        close(fd);
        handleError("Incomplete write");
    }

    // Close the file
    if (close(fd) == -1) {
        handleError("Failed to close file after writing");
    }

    // Open the file for reading
    fd = open(filename, O_RDONLY);
    if (fd == -1) {
        handleError("Failed to open file for reading");
    }

    // Reset the file pointer to the beginning of the file
    if (lseek(fd, 0, SEEK_SET) == -1) {
        close(fd);
        handleError("Failed to reset file pointer");
    }

    // Read from the file
    bytesRead = read(fd, buffer, sizeof(buffer) - 1);
    if (bytesRead == -1) {
        close(fd);
        handleError("Failed to read from file");
    }

    // Null-terminate the buffer to print as a string
    buffer[bytesRead] = '\0';
    std::cout << "File contents: " << buffer << std::endl;

    // Close the file
    if (close(fd) == -1) {
        handleError("Failed to close file after reading");
    }

    // Delete the file
    if (unlink(filename) == -1) {
        handleError("Failed to delete file");
    }

    return 0;
}
